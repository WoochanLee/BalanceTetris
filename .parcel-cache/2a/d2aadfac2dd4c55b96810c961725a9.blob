// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"3Imd1":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "0fa2489aa94c8731ee2aee9f3fafb3e2";
// @flow
/*global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE*/
/*::
import type {
HMRAsset,
HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
(string): mixed;
cache: {|[string]: ParcelModule|};
hotData: mixed;
Module: any;
parent: ?ParcelRequire;
isParcelRequire: true;
modules: {|[string]: [Function, {|[string]: string|}]|};
HMR_BUNDLE_ID: string;
root: ParcelRequire;
}
interface ParcelModule {
hot: {|
data: mixed,
accept(cb: (Function) => void): void,
dispose(cb: (mixed) => void): void,
// accept(deps: Array<string> | string, cb: (Function) => void): void,
// decline(): void,
_acceptCallbacks: Array<(Function) => void>,
_disposeCallbacks: Array<(mixed) => void>,
|};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || (function () {}));
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, /*: {|[string]: boolean|}*/
acceptedAssets, /*: {|[string]: boolean|}*/
/*: {|[string]: boolean|}*/
assetsToAccept;
function getHostname() {
  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
  return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = getHostname();
  var port = getPort();
  var protocol = HMR_SECURE || location.protocol == 'https:' && !(/localhost|127.0.0.1|0.0.0.0/).test(hostname) ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
  // $FlowFixMe
  ws.onmessage = function (event) /*: {data: string, ...}*/
  {
    checkedAssets = {
      /*: {|[string]: boolean|}*/
    };
    acceptedAssets = {
      /*: {|[string]: boolean|}*/
    };
    assetsToAccept = [];
    var data = /*: HMRMessage*/
    JSON.parse(event.data);
    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);
      // Handle HMR Update
      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        if (didAccept) {
          handled = true;
        }
      });
      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(module.bundle.root, asset);
        });
        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];
          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }
    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      }
      // Render the fancy html overlay
      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      // $FlowFixMe
      document.body.appendChild(overlay);
    }
  };
  ws.onerror = function (e) {
    console.error(e.message);
  };
  ws.onclose = function (e) {
    if (undefined !== 'test') {
      console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
    console.log('[parcel] âœ¨ Error resolved');
  }
}
function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          ðŸš¨ ${diagnostic.message}
        </div>
        <pre>
          ${stack}
        </pre>
        <div>
          ${diagnostic.hints.map(hint => '<div>' + hint + '</div>').join('')}
        </div>
      </div>
    `;
  }
  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]>*/
{
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function updateLink(link) {
  var newLink = link.cloneNode();
  newLink.onload = function () {
    if (link.parentNode !== null) {
      // $FlowFixMe
      link.parentNode.removeChild(link);
    }
  };
  newLink.setAttribute('href', // $FlowFixMe
  link.getAttribute('href').split('?')[0] + '?' + Date.now());
  // $FlowFixMe
  link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
  if (cssTimeout) {
    return;
  }
  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      // $FlowFixMe[incompatible-type]
      var href = /*: string*/
      links[i].getAttribute('href');
      var hostname = getHostname();
      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
      var absolute = (/^https?:\/\//i).test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
      if (!absolute) {
        updateLink(links[i]);
      }
    }
    cssTimeout = null;
  }, 50);
}
function hmrApply(bundle, /*: ParcelRequire*/
asset) /*:  HMRAsset*/
{
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (asset.type === 'css') {
    reloadCSS();
    return;
  }
  let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
  if (deps) {
    var fn = new Function('require', 'module', 'exports', asset.output);
    modules[asset.id] = [fn, deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, /*: ParcelRequire*/
id, /*: ParcelRequire*/
/*: string*/
depsByBundle) /*: ?{ [string]: { [string]: string } }*/
{
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
    // If we reached the root bundle without finding where the asset should go,
    // there's nothing to do. Mark as "accepted" so we don't reload the page.
    if (!bundle.parent) {
      return true;
    }
    return hmrAcceptCheck(bundle.parent, id, depsByBundle);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(module.bundle.root, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1], null);
  });
}
function hmrAcceptRun(bundle, /*: ParcelRequire*/
id) /*: string*/
{
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(module.bundle.root, id);
      });
      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }
  acceptedAssets[id] = true;
}

},{}],"5rkFb":[function(require,module,exports) {
require("./utils/util");
require("./components/control");
require("./components/system");

},{"./components/control":"7ddgW","./components/system":"5Bask","./utils/util":"53kCI"}],"7ddgW":[function(require,module,exports) {
var _game = require("./game");
window.onkeydown = e => {
  handleKeyboardEvent(e);
};
function handleKeyboardEvent(e) {
  if (isGameOver) {
    return;
  }
  switch (e.code) {
    case "ArrowLeft":
      _game.gameScreen.onEventLeftArrow();
      break;
    case "ArrowRight":
      _game.gameScreen.onEventRightArrow();
      break;
    case "ArrowDown":
      _game.gameScreen.onEventDownArrow();
      break;
    case "ArrowUp":
      _game.gameScreen.onEventUpArrow();
      break;
    case "Space":
      _game.gameScreen.onEventSpace();
      break;
    case "ShiftLeft":
      _game.gameScreen.onEventShift();
      break;
    case "KeyQ":
      _game.gameScreen.onEventKeyQ();
      break;
    case "KeyE":
      _game.gameScreen.onEventKeyE();
      break;
    case "KeyZ":
      _game.gameScreen.onEventKeyZ();
      break;
    case "KeyC":
      _game.gameScreen.onEventKeyC();
      break;
  }
  _game.gameScreen.drawBlocks();
}

},{"./game":"72qd1"}],"72qd1":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
var _screen = require("./screen");
const gameScreen = new _screen.GameScreen();
exports.default = gameScreen;

},{"./screen":"6jqjl","@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"6jqjl":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "GameScreen", function () {
  return GameScreen;
});
var _rendererRenderer = require("../../renderer/renderer");
var _gameBlock = require("../game/block");
var _gameBlockShift = require("../game/block-shift");
var _resourcesAudioPlayer = require("../../resources/audio-player");
var _resourcesAudioPlayerDefault = _parcelHelpers.interopDefault(_resourcesAudioPlayer);
/**
* canvas setting
*/
const topMargin = -20;
const leftMargin = 120;
/**
* block UI setting
*/
const borderWidth = 0;
const blockSize = 25;
const widthBlockCount = 10;
const widthBlockPaddingCount = 3;
const heightBlockCount = 25;
const hideTopLine = 1;
const shadowWidth = 3;
const outBorderBlockCount = 3;
const blockShadowOpacity = "cc";
const blockShadowOpacity2 = "55";
class GameScreen {
  constructor() {
    this.renderer = new _rendererRenderer.Renderer();
    this.audioPlayer = new _resourcesAudioPlayerDefault.default();
    this.canvas = document.getElementById("canvas");
    this.background = {};
    this.background.canvas = document.getElementById("background");
    this.background.ctx = this.background.canvas.getContext("2d");
    this.shouldUpdateStackedLayer = false;
    this.ctx = canvas.getContext("2d");
    this.stackedBlock = new _gameBlock.StakedBlock();
    this.controlBlock = new _gameBlock.ControlBlock();
    this.shiftBlock = new _gameBlockShift.ShiftBlock();
    this.previewBlockManager = new PreviewBlockManager();
    this.isSpaceDownRunning = false;
    this.collisionDelay = 0;
    this.init();
  }
  init() {
    this.flowGravityWithDraw();
  }
  drawBlocks() {
    this.renderer.renderWtihMerge(this.controlBlock.blockArray, this.stackedBlock.blockArray);
    this.drawNextBlocks();
    this.drawShiftBlock();
  }
  drawNextBlocks() {
    this.previewBlockManager.setBlockType(this.controlBlock.previewBlockQueue);
    this.previewBlockManager.draw(this.ctx);
  }
  drawShiftBlock() {
    this.shiftBlock.draw(this.ctx);
  }
  flowGravityWithDraw() {
    this.flowGravity();
    this.drawBlocks();
  }
  flowGravity() {
    let collisionCheckTmpArray = copyBlockArray(this.controlBlock.blockArray);
    if (couldBlockMoveToBottom(collisionCheckTmpArray, this.stackedBlock.blockArray)) {
      moveToBottomOneLine(this.controlBlock.blockArray);
      rewindTimer();
    } else if (this.collisionDelay < collisionDelayCount) {
      this.collisionDelay++;
    } else {
      this.audioPlayer.play(dropSound);
      this.shiftBlock.isAlreadyShiftedThisTime = false;
      this.isSpaceDownRunning = false;
      this.collisionDelay = 0;
      this.addBlocksToStackedArray(this.controlBlock.blockArray, this.stackedBlock.blockArray);
      let removedLineCount = this.removeCompletedLine(0);
      addScore(removedLineCount);
      if (this.checkIsGameOver(this.stackedBlock.blockArray)) {
        this.controlBlock.removeControlBlock();
        this.audioPlayer.play(gameOverSound);
        gameOver();
      } else {
        this.controlBlock.addNewControlBlock();
        levelUp();
        this.flowGravityWithDraw();
        rewindTimer();
      }
    }
  }
  removeCompletedLine(lineCount) {
    let stackedBlockArray = this.stackedBlock.blockArray;
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      let isCompletedLine = true;
      for (let x = outBorderBlockCount; x < widthBlockCount + outBorderBlockCount; x++) {
        if (!stackedBlockArray[x][y].isExist) {
          isCompletedLine = false;
          break;
        }
      }
      if (isCompletedLine) {
        this.removeLine(y);
        return this.removeCompletedLine(lineCount + 1);
      }
    }
    if (lineCount > 0) {
      this.audioPlayer.play(clearLineSound);
    }
    return lineCount;
  }
  removeLine(removeY) {
    let stackedBlockArray = this.stackedBlock.blockArray;
    for (let y = removeY; y > 0; y--) {
      for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
        copySingleBlock(stackedBlockArray[x][y], stackedBlockArray[x][y - 1]);
      }
    }
  }
  addBlocksToStackedArray(controlBlocks, stackedBlocks) {
    for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
      for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
        if (controlBlocks[x][y].isExist) {
          copySingleBlock(stackedBlocks[x][y], controlBlocks[x][y]);
        }
      }
    }
    this.shouldUpdateStackedLayer = true;
  }
  shiftControlBlock() {
    if (this.shiftBlock.isAlreadyShiftedThisTime) {
      return;
    }
    this.shiftBlock.isAlreadyShiftedThisTime = true;
    this.audioPlayer.play(shiftSound);
    if (this.shiftBlock.isShiftedBlockEmpty()) {
      this.shiftBlock.setShiftBlock(this.controlBlock.controlBlockType);
      this.controlBlock.addNewControlBlock();
    } else {
      let tmpBlockType = this.shiftBlock.shiftedBlock;
      this.shiftBlock.setShiftBlock(this.controlBlock.controlBlockType);
      this.changeControlBlock(tmpBlockType);
    }
    this.flowGravityWithDraw();
  }
  changeControlBlock(controlBlockType) {
    this.controlBlock.changeContorlBlock(controlBlockType);
  }
  checkIsGameOver(stackedBlocks) {
    for (let x = outBorderBlockCount; x < widthBlockCount + outBorderBlockCount; x++) {
      if (stackedBlocks[x][1].isExist) {
        return true;
      }
    }
    return false;
  }
  reDraw() {
    this.drawBlocks();
  }
  onEventLeftArrow() {
    if (couldBlockMoveToLeft(this.controlBlock.blockArray, this.stackedBlock.blockArray)) {
      moveToLeftOneLine(this.controlBlock.blockArray);
    }
  }
  onEventRightArrow() {
    if (couldBlockMoveToRight(this.controlBlock.blockArray, this.stackedBlock.blockArray)) {
      moveToRightOneLine(this.controlBlock.blockArray);
    }
  }
  onEventDownArrow() {
    this.flowGravityWithDraw();
  }
  onEventUpArrow() {
    this.controlBlock.rotate(this.controlBlock, this.controlBlock.blockArray, this.stackedBlock.blockArray, allowableRotationRange, true);
  }
  onEventSpace() {
    this.isSpaceDownRunning = true;
    while (this.isSpaceDownRunning) {
      this.flowGravity();
    }
    this.drawBlocks();
  }
  onEventShift() {
    this.shiftControlBlock();
  }
  onEventKeyQ() {
    this.controlBlock.rotate(this.controlBlock, this.controlBlock.blockArray, this.stackedBlock.blockArray, allowableRotationRange, false);
  }
  onEventKeyE() {
    this.controlBlock.rotate(this.controlBlock, this.controlBlock.blockArray, this.stackedBlock.blockArray, allowableRotationRange, true);
  }
  onEventKeyZ() {
    this.controlBlock.rotate(this.controlBlock, this.controlBlock.blockArray, this.stackedBlock.blockArray, allowableRotationRange, false);
  }
  onEventKeyC() {
    this.controlBlock.rotate(this.controlBlock, this.controlBlock.blockArray, this.stackedBlock.blockArray, allowableRotationRange, true);
  }
}

},{"../../renderer/renderer":"r8bQm","../game/block":"1WA8R","../game/block-shift":"2RQlU","../../resources/audio-player":"7iJYX","@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"r8bQm":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "Renderer", function () {
  return Renderer;
});
/*
renderer.js

This is a rendering module.
Authored by BT community

Renderer's goal is to receive the blocks and draw them optimally.

renderer's interface must be simple.

'renderWithMerge(first, second)` function is a render call function which
merge block arrays called 'stacked' and 'control' for the current game system.

Do not call _ prefixed function outside of this class which means 'private'

*/
function initBlockArray(blockArray) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    blockArray[x] = new Array(heightBlockCount + outBorderBlockCount);
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      blockArray[x][y] = {
        isExisted: false,
        isDifferent: false,
        blockColor: null
      };
    }
  }
}
class Renderer {
  constructor() {
    this.main = {};
    this.background = {};
    this.main.canvas = document.getElementById("canvas");
    this.main.contxt = this.main.canvas.getContext("2d");
    this.background.canvas = document.getElementById("background");
    this.background.contxt = this.background.canvas.getContext("2d");
    this.previousRenderBlocks = new Array(widthBlockCount + outBorderBlockCount * 2);
    this.mergeCache = new Array(widthBlockCount + outBorderBlockCount * 2);
    initBlockArray(this.previousRenderBlocks);
    initBlockArray(this.mergeCache);
    this._initializeBackgroundLayer();
  }
  renderWtihMerge(first, second) {
    const renderTarget = this._mergeArray(first, second);
    this._markDifferenceBetweenPreviousRenderedStatus(renderTarget);
    for (let x = outBorderBlockCount; x < widthBlockCount + outBorderBlockCount; x++) {
      for (let y = hideTopLine; y < heightBlockCount; y++) {
        let block = this.previousRenderBlocks[x][y];
        if (block.isDifferent) {
          this._clearPrevRect(x, y, this.main.contxt);
          if (renderTarget[x][y].isExist) {
            let blockColor = renderTarget[x][y].blockColor;
            this._drawBlock(x, y, this.main.contxt, blockColor);
            this._drawTopLeftShadow(x, y, this.main.contxt, blockColor);
            this._drawBottomRightShadow(x, y, this.main.contxt, blockColor);
          }
          block.isDifferent = false;
        }
        block.isExist = renderTarget[x][y].isExist;
      }
    }
  }
  _initializeBackgroundLayer() {
    for (let x = outBorderBlockCount; x < widthBlockCount + outBorderBlockCount; x++) {
      let blockColor = "#37393A";
      for (let y = hideTopLine; y < heightBlockCount; y++) {
        this._drawBlock(x, y, this.background.contxt, blockColor);
        this._drawTopLeftShadow(x, y, this.background.contxt, blockColor);
      }
    }
  }
  _mergeArray(first, second) {
    for (let x = outBorderBlockCount; x < widthBlockCount + outBorderBlockCount; x++) {
      for (let y = hideTopLine; y < heightBlockCount; y++) {
        this.mergeCache[x][y].isExist = false;
        this.mergeCache[x][y].blockColor = null;
        if (first[x][y].isExist) {
          this.mergeCache[x][y].isExist = true;
          this.mergeCache[x][y].blockColor = first[x][y].blockColor;
        }
        if (second[x][y].isExist) {
          this.mergeCache[x][y].isExist = true;
          this.mergeCache[x][y].blockColor = second[x][y].blockColor;
        }
      }
    }
    return this.mergeCache;
  }
  _markDifferenceBetweenPreviousRenderedStatus(current) {
    for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
      for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
        this.previousRenderBlocks[x][y].isDifferent = this.previousRenderBlocks[x][y].isExist != current[x][y].isExist || this.previousRenderBlocks[x][y].blockColor != current[x][y].blockColor;
      }
    }
  }
  _drawBlock(x, y, ctx, color) {
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin, blockSize, blockSize);
    ctx.fillStyle = color + blockShadowOpacity;
    ctx.fillRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin, blockSize, blockSize);
  }
  _drawTopLeftShadow(x, y, ctx, color) {
    ctx.fillStyle = color + blockShadowOpacity2;
    ctx.fillRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin, blockSize, shadowWidth);
    ctx.fillRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin, shadowWidth, blockSize);
  }
  _drawBottomRightShadow(x, y, ctx, color) {
    ctx.fillStyle = color;
    ctx.fillRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin + blockSize - shadowWidth, blockSize, shadowWidth);
    ctx.fillRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin + blockSize - shadowWidth, borderWidth * y + blockSize * y + topMargin, shadowWidth, blockSize);
  }
  _clearPrevRect(x, y, ctx) {
    ctx.clearRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin, y, blockSize, blockSize);
    ctx.clearRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin + blockSize - shadowWidth, blockSize, shadowWidth);
    ctx.clearRect(borderWidth * (x - outBorderBlockCount) + blockSize * (x - outBorderBlockCount) + leftMargin, borderWidth * y + blockSize * y + topMargin, blockSize, blockSize);
  }
}

},{"@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"5gA8y":[function(require,module,exports) {
"use strict";

exports.interopDefault = function (a) {
  return a && a.__esModule ? a : {
    default: a
  };
};

exports.defineInteropFlag = function (a) {
  Object.defineProperty(a, '__esModule', {
    value: true
  });
};

exports.exportAll = function (source, dest) {
  Object.keys(source).forEach(function (key) {
    if (key === 'default' || key === '__esModule') {
      return;
    } // Skip duplicate re-exports when they have the same value.


    if (key in dest && dest[key] === source[key]) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function () {
        return source[key];
      }
    });
  });
  return dest;
};

exports.export = function (dest, destName, get) {
  Object.defineProperty(dest, destName, {
    enumerable: true,
    get: get
  });
};
},{}],"1WA8R":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "ControlBlock", function () {
  return ControlBlock;
});
_parcelHelpers.export(exports, "ControlBlockType", function () {
  return ControlBlockType;
});
_parcelHelpers.export(exports, "StakedBlock", function () {
  return StakedBlock;
});
var _blockBlueprints = require("./block-blueprints");
var _utilsUtil = require("../../utils/util");
function findBlockRefPoint(blockArray) {
  let refPoint = null;
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      if (blockArray[x][y].isExist) {
        refPoint = {
          x: x,
          y: y
        };
        break;
      }
    }
    if (refPoint != null) break;
  }
  return refPoint;
}
function getRotatedBlock(rotationBlueprint, reverseRotationBlueprint, newRotateDirection, controlBlock, controlBlockArray, isForwardRotation) {
  let tmpArray = copyBlockArray(controlBlockArray);
  let refPoint = findBlockRefPoint(tmpArray);
  clearBlockArray(tmpArray);
  if (rotationBlueprint.length == 0) {
    return null;
  }
  let r;
  if (isForwardRotation) {
    r = rotationBlueprint[newRotateDirection];
  } else {
    r = reverseRotationBlueprint[newRotateDirection];
  }
  for (let i = 0; i < r.length; i++) {
    let rotatedX = refPoint.x + r[i][0];
    let rotatedY = refPoint.y + r[i][1];
    if (rotatedX >= 0 && rotatedX < widthBlockCount + outBorderBlockCount * 2 && rotatedY >= 0 && rotatedY < heightBlockCount + outBorderBlockCount) {
      tmpArray[rotatedX][rotatedY].isExist = true;
      tmpArray[rotatedX][rotatedY].blockColor = controlBlock.controlBlockType.blockType.blockColor;
    } else {
      return null;
    }
  }
  return tmpArray;
}
function isInBorder(blockArray) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      if (blockArray[x][y].isExist == true && !(x >= outBorderBlockCount && x < widthBlockCount + outBorderBlockCount && y >= 0 && y < heightBlockCount)) {
        return false;
      }
    }
  }
  return true;
}
function getNextRotateDirection(currentRotateDirection, rotationAmount) {
  let nextRotationDirection = currentRotateDirection + 1;
  if (nextRotationDirection < rotationAmount) {
    return nextRotationDirection;
  } else {
    return 0;
  }
}
function getPrevRotateDirection(currentRotateDirection, rotationAmount) {
  let prevRotationDirection = currentRotateDirection - 1;
  if (prevRotationDirection < 0) {
    return rotationAmount - 1;
  } else {
    return prevRotationDirection;
  }
}
class ControlBlock {
  constructor() {
    this.currentRotateDirection = 0;
    this.initBlockTypes();
    this.initPreviewBlocks();
    this.blockArray = new Array(widthBlockCount + outBorderBlockCount * 2);
    this.controlBlockCount = 0;
    initBlockArray(this.blockArray);
    this.initControlBlockType();
  }
  initBlockTypes() {
    this.blockTypeOne = new _blockBlueprints.BlockTypeOne();
    this.blockTypeTwo = new _blockBlueprints.BlockTypeTwo();
    this.blockTypeThree = new _blockBlueprints.BlockTypeThree();
    this.blockTypeFour = new _blockBlueprints.BlockTypeFour();
    this.blockTypeFive = new _blockBlueprints.BlockTypeFive();
    this.blockTypeSix = new _blockBlueprints.BlockTypeSix();
    this.blockTypeSeven = new _blockBlueprints.BlockTypeSeven();
  }
  initControlBlockType() {
    this.addNewControlBlock();
  }
  initPreviewBlocks() {
    this.previewBlockQueue = new _utilsUtil.Queue();
    for (let i = 0; i < 2; i++) {
      this.enqueueRandomTypePack();
    }
  }
  enqueueRandomTypePack() {
    let array = this.makeRandomTypePack();
    for (let i = 0; i < array.length; i++) {
      this.previewBlockQueue.enqueue(new ControlBlockType(array[i]));
    }
  }
  makeRandomTypePack() {
    return _utilsUtil.shuffleArray([this.blockTypeOne, this.blockTypeTwo, this.blockTypeThree, this.blockTypeFour, this.blockTypeFive, this.blockTypeSix, this.blockTypeSeven]);
  }
  changeContorlBlock(controlBlockType) {
    this.controlBlockType = controlBlockType;
    this.refreshBlockArray();
  }
  addNewControlBlock() {
    this.controlBlockCount++;
    this.controlBlockType = this.previewBlockQueue.dequeue();
    if (this.controlBlockCount % 7 == 0) {
      this.enqueueRandomTypePack();
    }
    this.refreshBlockArray();
  }
  refreshBlockArray() {
    this.currentRotateDirection = 0;
    clearBlockArray(this.blockArray);
    let shape = this.controlBlockType.blockType.shape;
    for (let i = 0; i < shape.length; i++) {
      let block = this.blockArray[shape[i][0] + widthBlockPaddingCount + outBorderBlockCount][shape[i][1]];
      block.isExist = true;
      block.blockColor = this.controlBlockType.blockType.blockColor;
    }
  }
  rotate(controlBlock, controlBlockArray, stackedBlockArray, allowableRange, isForwardRotation) {
    let newRotateDirection;
    if (isForwardRotation) {
      newRotateDirection = getNextRotateDirection(this.currentRotateDirection, this.controlBlockType.blockType.rotationBlueprint.length);
    } else {
      newRotateDirection = getPrevRotateDirection(this.currentRotateDirection, this.controlBlockType.blockType.reverseRotationBlueprint.length);
    }
    let rotatedBlockArray = getRotatedBlock(this.controlBlockType.blockType.rotationBlueprint, this.controlBlockType.blockType.reverseRotationBlueprint, newRotateDirection, controlBlock, controlBlockArray, isForwardRotation);
    if (rotatedBlockArray == null) {
      return;
    }
    let couldKickRotate = this.rotateBlock(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, false, 0, 0, 0);
    if (!couldKickRotate) {
      this.rotateBlock(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, true, 0, 0, 0);
    }
  }
  rotateBlock(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount) {
    if (!isInBorder(rotatedBlockArray) || isOverlaped(rotatedBlockArray, stackedBlockArray)) {
      if (allowableRange > 0) {
        let couldLeftMoveRotate;
        let couldRightMoveRotate;
        if (moveLeftCount >= allowableRotationRange - 1) {
          couldLeftMoveRotate = false;
        } else {
          couldLeftMoveRotate = this.checkLeftMoveRotation(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount);
        }
        if (couldLeftMoveRotate) {
          return true;
        } else {
          if (moveRightCount >= allowableRotationRange - 1) {
            couldRightMoveRotate = false;
          } else {
            couldRightMoveRotate = this.checkRightMoveRotation(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount);
          }
        }
        if (isSpin) {
          if (couldRightMoveRotate) {
            return true;
          } else {
            if (moveBottomCount >= allowableRotationRange - 1) {
              return false;
            } else {
              return this.checkBottomMoveRotation(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount);
            }
          }
        } else {
          return couldRightMoveRotate;
        }
      } else {
        return false;
      }
    }
    this.currentRotateDirection = newRotateDirection;
    controlBlock.blockArray = rotatedBlockArray;
    return true;
  }
  checkLeftMoveRotation(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount) {
    let tmpArray = copyBlockArray(rotatedBlockArray);
    if (!isBlockReachedToLeftBorder(tmpArray)) {
      moveToLeftOneLine(tmpArray);
      return this.rotateBlock(newRotateDirection, controlBlock, tmpArray, stackedBlockArray, allowableRange - 1, isForwardRotation, isSpin, moveLeftCount + 1, moveRightCount, moveBottomCount);
    } else {
      return false;
    }
  }
  checkRightMoveRotation(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount) {
    let tmpArray = copyBlockArray(rotatedBlockArray);
    if (!isBlockReachedToRightBorder(tmpArray)) {
      moveToRightOneLine(tmpArray);
      return this.rotateBlock(newRotateDirection, controlBlock, tmpArray, stackedBlockArray, allowableRange - 1, isForwardRotation, isSpin, moveLeftCount, moveRightCount + 1, moveBottomCount);
    } else {
      return false;
    }
  }
  checkBottomMoveRotation(newRotateDirection, controlBlock, rotatedBlockArray, stackedBlockArray, allowableRange, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount) {
    let tmpArray = copyBlockArray(rotatedBlockArray);
    if (!isBlockReachedToBottomBorder(tmpArray)) {
      moveToBottomOneLine(tmpArray);
      return this.rotateBlock(newRotateDirection, controlBlock, tmpArray, stackedBlockArray, allowableRange - 1, isForwardRotation, isSpin, moveLeftCount, moveRightCount, moveBottomCount + 1);
    } else {
      return false;
    }
  }
  removeControlBlock() {
    clearBlockArray(this.blockArray);
  }
}
class ControlBlockType {
  constructor(blockType) {
    this.blockType = blockType;
  }
}
class StakedBlock {
  constructor() {
    this.blockArray = new Array(widthBlockCount + outBorderBlockCount * 2);
    initBlockArray(this.blockArray);
  }
}
function initBlockArray(blockArray) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    blockArray[x] = new Array(heightBlockCount + outBorderBlockCount);
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      blockArray[x][y] = {
        isExist: false,
        isPrevExisted: false
      };
    }
  }
  clearBlockArray(blockArray);
}
function moveToBottomOneLine(blockArray) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    for (let y = heightBlockCount + outBorderBlockCount - 1; y != 0; y--) {
      copySingleBlockWithPrev(blockArray[x][y], blockArray[x][y - 1], blockArray[x][y].isExist);
    }
    blockArray[x][0].isExist = false;
  }
}
function moveToLeftOneLine(blockArray) {
  for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
    for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2 - 1; x++) {
      copySingleBlockWithPrev(blockArray[x][y], blockArray[x + 1][y], blockArray[x][y].isExist);
    }
    blockArray[widthBlockCount + outBorderBlockCount * 2 - 1][y].isExist = false;
  }
}
function moveToRightOneLine(blockArray) {
  for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
    for (let x = widthBlockCount + outBorderBlockCount * 2 - 1; x != 0; x--) {
      copySingleBlockWithPrev(blockArray[x][y], blockArray[x - 1][y], blockArray[x][y].isExist);
    }
    blockArray[0][y].isExist = false;
  }
}
function couldBlockMoveToBottom(controlBlocks, stackedBlocks) {
  let collisionCheckTmpArray = copyBlockArray(controlBlocks);
  let isBlockReachToBottomSide = isBlockReachedToBottomBorder(controlBlocks);
  let isBottomCollided = isBottomSideCollided(collisionCheckTmpArray, stackedBlocks);
  if (isBlockReachToBottomSide || isBottomCollided) {
    return false;
  }
  return true;
}
function couldBlockMoveToLeft(controlBlocks, stackedBlocks) {
  let collisionCheckTmpArray = copyBlockArray(controlBlocks);
  let isBlockReachToLeftSide = isBlockReachedToLeftBorder(controlBlocks);
  let isLeftCollided = isLeftSideCollided(collisionCheckTmpArray, stackedBlocks);
  if (isBlockReachToLeftSide || isLeftCollided) {
    return false;
  }
  return true;
}
function couldBlockMoveToRight(controlBlocks, stackedBlocks) {
  let collisionCheckTmpArray = copyBlockArray(controlBlocks);
  let isBlockReachToRightSide = isBlockReachedToRightBorder(controlBlocks);
  let isRightCollided = isRightSideCollided(collisionCheckTmpArray, stackedBlocks);
  if (isBlockReachToRightSide || isRightCollided) {
    return false;
  }
  return true;
}
function isBottomSideCollided(blockArray1, blockArray2) {
  moveToBottomOneLine(blockArray1);
  return isOverlaped(blockArray1, blockArray2);
}
function isLeftSideCollided(blockArray1, blockArray2) {
  moveToLeftOneLine(blockArray1);
  return isOverlaped(blockArray1, blockArray2);
}
function isRightSideCollided(blockArray1, blockArray2) {
  moveToRightOneLine(blockArray1);
  return isOverlaped(blockArray1, blockArray2);
}
function isOverlaped(blockArray1, blockArray2) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      if (blockArray1[x][y].isExist && blockArray2[x][y].isExist) {
        return true;
      }
    }
  }
  return false;
}
function isBlockReachedToBottomBorder(blockArray) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    if (blockArray[x][heightBlockCount - 1].isExist) {
      return true;
    }
  }
  return false;
}
function isBlockReachedToLeftBorder(blockArray) {
  for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
    if (blockArray[outBorderBlockCount][y].isExist) {
      return true;
    }
  }
  return false;
}
function isBlockReachedToRightBorder(blockArray) {
  for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
    if (blockArray[widthBlockCount + outBorderBlockCount - 1][y].isExist) {
      return true;
    }
  }
  return false;
}
function clearBlockArray(blockArray) {
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      if (blockArray[x][y].isExist) blockArray[x][y].isPrevExisted = true;
      blockArray[x][y].isExist = false;
      blockArray[x][y].blockColor = null;
    }
  }
}
function copyBlockArray(blockArray) {
  let tmpArray = new Array(widthBlockCount + outBorderBlockCount * 2);
  initBlockArray(tmpArray);
  for (let x = 0; x < widthBlockCount + outBorderBlockCount * 2; x++) {
    for (let y = 0; y < heightBlockCount + outBorderBlockCount; y++) {
      copySingleBlock(tmpArray[x][y], blockArray[x][y]);
    }
  }
  return tmpArray;
}
function copySingleBlockWithPrev(blockTo, blockFrom, prev) {
  blockTo.isPrevExisted = prev;
  copySingleBlock(blockTo, blockFrom);
}
function copySingleBlock(blockTo, blockFrom) {
  blockTo.isExist = blockFrom.isExist;
  blockTo.blockColor = blockFrom.blockColor;
}

},{"./block-blueprints":"4oZ2E","../../utils/util":"53kCI","@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"4oZ2E":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "BlockTypeFive", function () {
  return BlockTypeFive;
});
_parcelHelpers.export(exports, "BlockTypeFour", function () {
  return BlockTypeFour;
});
_parcelHelpers.export(exports, "BlockTypeOne", function () {
  return BlockTypeOne;
});
_parcelHelpers.export(exports, "BlockTypeSeven", function () {
  return BlockTypeSeven;
});
_parcelHelpers.export(exports, "BlockTypeSix", function () {
  return BlockTypeSix;
});
_parcelHelpers.export(exports, "BlockTypeThree", function () {
  return BlockTypeThree;
});
_parcelHelpers.export(exports, "BlockTypeTwo", function () {
  return BlockTypeTwo;
});
/**
****â–¡â–¡â–¡â–¡****
**/
class BlockTypeOne {
  constructor() {
    this.widthBlockCount = 4;
    this.widthBlockMarginCount = 0;
    this.heightBlockCount = 1;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#8CD6F3";
    this.shape = [[0, 0], [1, 0], [2, 0], [3, 0]];
    this.rotationBlueprint = [[[-2, 1], [-1, 1], [0, 1], [1, 1]], [[2, -1], [2, 0], [2, 1], [2, 2]]];
    this.reverseRotationBlueprint = [[[-2, 1], [-1, 1], [0, 1], [1, 1]], [[2, -1], [2, 0], [2, 1], [2, 2]]];
  }
}
/**
*****â–¡******
****â–¡â–¡â–¡*****
**/
class BlockTypeTwo {
  constructor() {
    this.widthBlockCount = 3;
    this.widthBlockMarginCount = 1;
    this.heightBlockCount = 2;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#BC48A9";
    this.shape = [[1, 1], [2, 0], [2, 1], [3, 1]];
    this.rotationBlueprint = [[[0, 0], [1, -1], [1, 0], [2, 0]], [[1, -1], [1, 0], [1, 1], [2, 0]], [[-1, 1], [0, 1], [0, 2], [1, 1]], [[0, 0], [1, -1], [1, 0], [1, 1]]];
    this.reverseRotationBlueprint = [[[-1, 1], [0, 0], [0, 1], [1, 1]], [[1, -1], [1, 0], [1, 1], [2, 0]], [[0, 0], [1, 0], [1, 1], [2, 0]], [[0, 0], [1, -1], [1, 0], [1, 1]]];
  }
}
/**
*****â–¡â–¡*****
*****â–¡â–¡*****
**/
class BlockTypeThree {
  constructor() {
    this.widthBlockCount = 2;
    this.widthBlockMarginCount = 1;
    this.heightBlockCount = 2;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#EFC23C";
    this.shape = [[1, 0], [1, 1], [2, 0], [2, 1]];
    this.rotationBlueprint = [];
    this.reverseRotationBlueprint = [];
  }
}
/**
****â–¡â–¡******
*****â–¡â–¡*****
**/
class BlockTypeFour {
  constructor() {
    this.widthBlockCount = 3;
    this.widthBlockMarginCount = 1;
    this.heightBlockCount = 2;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#CF3656";
    this.shape = [[1, 0], [2, 0], [2, 1], [3, 1]];
    this.rotationBlueprint = [[[0, -1], [1, -1], [1, 0], [2, 0]], [[0, 1], [0, 2], [1, 0], [1, 1]]];
    this.reverseRotationBlueprint = [[[0, -1], [1, -1], [1, 0], [2, 0]], [[0, 1], [0, 2], [1, 0], [1, 1]]];
  }
}
/**
*****â–¡â–¡*****
****â–¡â–¡******
**/
class BlockTypeFive {
  constructor() {
    this.widthBlockCount = 3;
    this.widthBlockMarginCount = 1;
    this.heightBlockCount = 2;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#96D038";
    this.shape = [[1, 1], [2, 0], [2, 1], [3, 0]];
    this.rotationBlueprint = [[[-1, 1], [0, 0], [0, 1], [1, 0]], [[1, -1], [1, 0], [2, 0], [2, 1]]];
    this.reverseRotationBlueprint = [[[-1, 1], [0, 0], [0, 1], [1, 0]], [[1, -1], [1, 0], [2, 0], [2, 1]]];
  }
}
/**
******â–¡****
****â–¡â–¡â–¡****
**/
class BlockTypeSix {
  constructor() {
    this.widthBlockCount = 3;
    this.widthBlockMarginCount = 1;
    this.heightBlockCount = 2;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#DD7E30";
    this.shape = [[1, 1], [2, 1], [3, 0], [3, 1]];
    this.rotationBlueprint = [[[0, 1], [1, 1], [2, 0], [2, 1]], [[0, -2], [0, -1], [0, 0], [1, 0]], [[0, 1], [0, 2], [1, 1], [2, 1]], [[0, 0], [1, 0], [1, 1], [1, 2]]];
    this.reverseRotationBlueprint = [[[0, 2], [1, 2], [2, 1], [2, 2]], [[0, -1], [0, 0], [0, 1], [1, 1]], [[0, 0], [0, 1], [1, 0], [2, 0]], [[0, -1], [1, -1], [1, 0], [1, 1]]];
  }
}
/**
****â–¡*******
****â–¡â–¡â–¡****
**/
class BlockTypeSeven {
  constructor() {
    this.widthBlockCount = 3;
    this.widthBlockMarginCount = 1;
    this.heightBlockCount = 2;
    this.heightBlockMarginCount = 0;
    this.blockColor = "#4E60E8";
    this.shape = [[1, 0], [1, 1], [2, 1], [3, 1]];
    this.rotationBlueprint = [[[-1, -1], [-1, 0], [0, 0], [1, 0]], [[1, 0], [1, 1], [1, 2], [2, 0]], [[-1, 0], [0, 0], [1, 0], [1, 1]], [[1, 1], [2, -1], [2, 0], [2, 1]]];
    this.reverseRotationBlueprint = [[[-1, 0], [-1, 1], [0, 1], [1, 1]], [[1, 0], [1, 1], [1, 2], [2, 0]], [[-1, -1], [0, -1], [1, -1], [1, 0]], [[1, 1], [2, -1], [2, 0], [2, 1]]];
  }
}

},{"@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"53kCI":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "logBlockArray", function () {
  return logBlockArray;
});
_parcelHelpers.export(exports, "shuffleArray", function () {
  return shuffleArray;
});
_parcelHelpers.export(exports, "Queue", function () {
  return Queue;
});
function logBlockArray(blockArray) {
  for (let y = 0; y < heightBlockCount; y++) {
    let line = "";
    for (let x = outBorderBlockCount; x < widthBlockCount + outBorderBlockCount * 2; x++) {
      if (blockArray[x][y].isExist) {
        line += "â–¡";
      } else {
        line += "â– ";
      }
    }
    console.log(line);
  }
}
const shuffleArray = array => {
  for (let i = 0; i < array.length; i++) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};
class Queue {
  constructor() {
    this._arr = [];
  }
  enqueue(item) {
    this._arr.push(item);
  }
  dequeue() {
    return this._arr.shift();
  }
  get(i) {
    return this._arr[i];
  }
}

},{"@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"2RQlU":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "ShiftBlock", function () {
  return ShiftBlock;
});
const shiftBackgroundColor = "#444444";
/**
* shift block setting
*/
const shiftBlockLocationX = 50;
const shiftBlockLocationY = 50;
const shiftBlockRadius = 45;
class ShiftBlock {
  constructor() {
    this.shiftBorderWidth = shiftBlockRadius / 45;
    this.shiftBlockSize = shiftBlockRadius * 4 / 15;
    this.shiftBlockShadowWidth = shiftBlockRadius / 15;
    this.shiftedBlock = null;
    this.isAlreadyShiftedThisTime = false;
  }
  setShiftBlock(controlBlockType) {
    this.shiftedBlock = controlBlockType;
    this.refreshData();
  }
  isShiftedBlockEmpty() {
    if (this.shiftedBlock == null) {
      return true;
    } else {
      return false;
    }
  }
  refreshData() {
    this.blockType = this.shiftedBlock.blockType;
    let widthBlockCount = this.blockType.widthBlockCount;
    let widthBlockMarginCount = this.blockType.widthBlockMarginCount;
    let heightBlockCount = this.blockType.heightBlockCount;
    let heightBlockMarginCount = this.blockType.heightBlockMarginCount;
    this.shiftBackgroundWidthPadding = shiftBlockRadius - this.shiftBlockSize * widthBlockMarginCount - this.shiftBorderWidth * widthBlockMarginCount - (this.shiftBlockSize * widthBlockCount + this.shiftBorderWidth * (widthBlockCount - 1)) / 2;
    this.shiftBackgroundHeightPadding = shiftBlockRadius - this.shiftBlockSize * heightBlockMarginCount - this.shiftBorderWidth * heightBlockMarginCount - (this.shiftBlockSize * heightBlockCount + (this.shiftBorderWidth * heightBlockCount - 1)) / 2;
  }
  draw(ctx) {
    this.drawBackgroundCircle(ctx);
    if (!this.isShiftedBlockEmpty()) {
      this.drawShiftBlock(ctx);
    }
  }
  drawBackgroundCircle(ctx) {
    ctx.fillStyle = shiftBackgroundColor;
    ctx.beginPath();
    ctx.arc(shiftBlockLocationX, shiftBlockLocationY, shiftBlockRadius, 0, Math.PI * 2, false);
    ctx.fill();
  }
  drawShiftBlock(ctx) {
    for (let i = 0; i < this.blockType.shape.length; i++) {
      let blockColor = this.blockType.blockColor;
      ctx.fillStyle = blockColor + blockShadowOpacity;
      let blockX = this.blockType.shape[i][0];
      let blockY = this.blockType.shape[i][1];
      let blockLocationX = shiftBlockLocationX + this.shiftBlockSize * blockX + this.shiftBorderWidth * blockX - shiftBlockRadius + this.shiftBackgroundWidthPadding;
      let blockLocationY = shiftBlockLocationY + this.shiftBlockSize * blockY + this.shiftBorderWidth * blockY - shiftBlockRadius + this.shiftBackgroundHeightPadding;
      ctx.fillRect(blockLocationX, blockLocationY, this.shiftBlockSize, this.shiftBlockSize);
      // draw shadow
      ctx.fillStyle = blockColor;
      ctx.fillRect(blockLocationX, blockLocationY, this.shiftBlockShadowWidth, this.shiftBlockSize);
      ctx.fillRect(blockLocationX, blockLocationY, this.shiftBlockSize, this.shiftBlockShadowWidth);
    }
  }
}

},{"@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"7iJYX":[function(require,module,exports) {
var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
require("./sounds");
class AudioPlayer {
  constructor() {}
  play(el) {
    if (!el.ended) {
      this._stop(el);
    }
    el.play();
  }
  _stop(el) {
    el.pause();
    el.currentTime = 0.0;
  }
}
exports.default = AudioPlayer;

},{"./sounds":"37ShX","@parcel/transformer-js/lib/esmodule-helpers.js":"5gA8y"}],"37ShX":[function(require,module,exports) {
const dropSound = document.getElementById("sound-drop");
const shiftSound = document.getElementById("sound-shift");
const clearLineSound = document.getElementById("sound-clear_line");
const gameOverSound = document.getElementById("sound-game_over");
},{}],"5Bask":[function(require,module,exports) {
var _game = require("./game");
let testButtonOn = false;
let timeId = null;
let currentDifficulty = 0;
let score = 0;
let levelText = document.getElementById("level");
let scoreText = document.getElementById("score");
let gameOverText = document.getElementById("game-over");
let chanImg = document.getElementById("chanImg");
let youngImg = document.getElementById("youngImg");
let isGameOver = false;
// function onClickTestButton() {
// if (testButtonOn) {
// clearInterval(timeId);
// } else {
// timeId = setInterval(
// () => gameScreen.flowGravity(),
// timePerLine * Math.pow(increaseSpeedPerDifficulty, currentDifficulty)
// );
// }
// testButtonOn = !testButtonOn;
// }
timeId = setInterval(() => _game.gameScreen.flowGravity(), timePerLine * Math.pow(increaseSpeedPerDifficulty, currentDifficulty));
function levelUp() {
  currentDifficulty++;
  levelText.textContent = `${currentDifficulty}`;
}
function rewindTimer() {
  clearInterval(timeId);
  timeId = setInterval(() => _game.gameScreen.flowGravityWithDraw(), timePerLine * Math.pow(increaseSpeedPerDifficulty, currentDifficulty));
}
function addScore(removedLineCount) {
  if (removedLineCount > 0) {
    score += removedLineCount * removedLineCount;
    scoreText.textContent = `${score}`;
  }
}
function gameOver() {
  isGameOver = true;
  clearInterval(timeId);
  gameOverText.style.visibility = "visible";
  if (score == 0) {
    makeFailEasterEgg();
  }
}
function makeFailEasterEgg() {
  chanImg.src = "res/chan_fail.png";
  youngImg.src = "res/young_fail.png";
}

},{"./game":"72qd1"}]},["3Imd1","5rkFb"], "5rkFb", "parcelRequireb3a6")

//# sourceMappingURL=index.HASH_REF_0fa2489aa94c8731ee2aee9f3fafb3e2.js.map
